*nurl.nvim.txt*       For Neovim >= 0.10.0       Last change: 2025 December 03

A Lua-based HTTP client for Neovim. Define requests in Lua files, manage
environments, add hooks, and view responses in beautiful split windows.

Body tabHeaders tabInfo tabRaw tabRequest pickerHistory picker
==============================================================================
1. Table of Contents                             *nurl.nvim-table-of-contents*

- |nurl.nvim-features|
- |nurl.nvim-requirements|
- |nurl.nvim-installation|
- |nurl.nvim-quick-start|
- |nurl.nvim-configuration|
- |nurl.nvim-commands|
- |nurl.nvim-request-format|
    - |nurl.nvim-dynamic-values|
    - |nurl.nvim-lazy-values|
    - |nurl.nvim-url-parts|
- |nurl.nvim-environments|
    - |nurl.nvim-environment-hooks|
- |nurl.nvim-api|
- |nurl.nvim-winbar|
- |nurl.nvim-highlight-groups|
- |nurl.nvim-recipes|
    - |nurl.nvim-1password-cli-for-secrets|
    - |nurl.nvim-oauth2-token-refresh|
    - |nurl.nvim-using-response-values|
    - |nurl.nvim-hmac-signature|
    - |nurl.nvim-environment-based-confirmation|
    - |nurl.nvim-response-validation|
    - |nurl.nvim-graphql-with-variables|
    - |nurl.nvim-file-upload-with-picker|


==============================================================================
2. Features                                               *nurl.nvim-features*

- **Lua-based requests** - Define HTTP requests as Lua tables with full language support
- **Environments** - Manage variables per environment (dev, staging, prod)
- **Request history** - SQLite-backed history with full request/response data
- **Response viewer** - Split window with body, headers, info, and raw curl output tabs
- **Hooks** - Pre/post hooks per request, or per environment (applies to all requests when env is active)
- **Picker integration** - Browse requests and history with snacks.nvim <https://github.com/folke/snacks.nvim> or telescope.nvim <https://github.com/nvim-telescope/telescope.nvim>


==============================================================================
3. Requirements                                       *nurl.nvim-requirements*

- Neovim >= 0.10.0
- `curl` in PATH
- snacks.nvim <https://github.com/folke/snacks.nvim> or telescope.nvim <https://github.com/nvim-telescope/telescope.nvim> (for pickers)
- Optional: `jq` for JSON formatting, `stylua` for environments file formatting


==============================================================================
4. Installation                                       *nurl.nvim-installation*

Using lazy.nvim <https://github.com/folke/lazy.nvim>:

>lua
    {
        "rodrigoscc/nurl.nvim",
        dependencies = { "folke/snacks.nvim" }, -- Optional
        dependencies = { -- Optional
            'nvim-telescope/telescope.nvim', tag = 'v0.1.9',
            dependencies = { 'nvim-lua/plenary.nvim' }
        },
        opts = {},
    }
<


==============================================================================
5. Quick Start                                         *nurl.nvim-quick-start*


1. CREATE A REQUEST FILE      *nurl.nvim-quick-start-1.-create-a-request-file*

Create `.nurl/requests.lua` in your project:

>lua
    return {
        {
            "https://jsonplaceholder.typicode.com/posts/1",
        },
        {
            "https://jsonplaceholder.typicode.com/posts",
            method = "POST",
            headers = {
                ["Content-Type"] = "application/json",
            },
            data = {
                title = "Hello",
                body = "World",
                userId = 1,
            },
        },
    }
<


2. RUN A REQUEST                      *nurl.nvim-quick-start-2.-run-a-request*

Position cursor on a request and run:

>vim
    :Nurl send_at_cursor
<

Or use the picker:

>vim
    :Nurl send
<


==============================================================================
6. Configuration                                     *nurl.nvim-configuration*

>lua
    require("nurl").setup({
        -- Project directory for Nurl files
        dir = ".nurl",
    
        -- Environments file name
        environments_file = "environments.lua",
    
        -- History settings
        history = {
            enabled = true,
            db_file = vim.fn.stdpath("data") .. "/nurl/history.sqlite3",
            max_history_items = 5000,
        },
    
        -- Response window config (see :help nvim_open_win)
        win_config = { split = "right" },
    
        -- Response formatters by filetype
        formatters = {
            json = {
                cmd = { "jq", "--sort-keys", "--indent", "2" },
                available = function()
                    return vim.fn.executable("jq") == 1
                end,
            },
        },
    
        -- Buffer keymaps
        buffers = {
            {
                "body",
                keys = {
                    ["<Tab>"] = "next_buffer",
                    ["<S-Tab>"] = "previous_buffer",
                    ["<C-r>"] = "rerun",
                    q = "close",
                },
            },
            {
                "headers",
                keys = {
                    ["<Tab>"] = "next_buffer",
                    ["<S-Tab>"] = "previous_buffer",
                    ["<C-r>"] = "rerun",
                    q = "close",
                },
            },
            {
                "info",
                keys = {
                    ["<Tab>"] = "next_buffer",
                    ["<S-Tab>"] = "previous_buffer",
                    ["<C-r>"] = "rerun",
                    q = "close",
                },
            },
            {
                "raw",
                keys = {
                    ["<Tab>"] = "next_buffer",
                    ["<S-Tab>"] = "previous_buffer",
                    ["<C-r>"] = "rerun",
                    q = "close",
                },
            },
        },
    })
<


==============================================================================
7. Commands                                               *nurl.nvim-commands*

  Command                 Description
  ----------------------- -----------------------------------------------
  :Nurl                   Project requests picker → send request
  :Nurl .                 Send request at cursor
  :Nurl %                 Current buffer requests picker → send request
  :Nurl <filepath>        File requests picker → send request
  :Nurl jump              Project requests picker → jump to definition
  :Nurl jump %            Current buffer requests picker → jump
  :Nurl jump <filepath>   File requests picker → jump
  :Nurl history           History picker → view response
  :Nurl resend            Recent requests picker → resend
  :Nurl resend <-n>       Resend nth last request (-1 = last)
  :Nurl env               Environment picker → activate
  :Nurl env <name>        Activate environment directly
  :Nurl env_file          Open environments file
  :Nurl yank              Project requests picker → yank curl command
  :Nurl yank .            Yank curl at cursor
  :Nurl yank %            Current buffer requests picker → yank
  :Nurl yank <filepath>   File requests picker → yank

==============================================================================
8. Request Format                                   *nurl.nvim-request-format*

>lua
    ---@class nurl.SuperRequest
    {
        -- Shorthand: URL as first element
        "https://api.example.com/users",
    
        -- or URL key as string, table of parts, or function
        url = "https://api.example.com/users",
        url = { "https://api.example.com", "v1", "users" },
        url = function() return "https://api.example.com/users/id" end,
    
        -- Optional: display name in pickers
        title = "Get all users",
        title = function() return "Dynamic title" end,
    
        -- Optional (defaults to GET)
        method = "POST",
    
        -- Optional headers: table or function
        headers = {
            ["Authorization"] = "Bearer token",
            ["Content-Type"] = "application/json",
        },
        headers = function() return { ["X-Request-Id"] = tostring(os.time()) } end,
    
        -- Body (use only one): table, string, or function
        data = { key = "value" },           -- Table: JSON encoded
        data = '{"raw": "json"}',           -- String: sent as-is
        data = function() return { ts = os.time() } end,
        form = { field = "value" },         -- multipart/form-data
        data_urlencode = { q = "search" },  -- URL encoded
    
        -- Additional curl args
        curl_args = { "--insecure", "--compressed" },
        curl_args = { "--proxy", "http://localhost:8080" },
    
        -- Hooks
        pre_hook = function(next, input)
            -- Called before sending, must call next() to proceed
            -- Modify request fields before sending
            next()
        end,
        post_hook = function(out)
            -- Called after curl completes
            -- out.request, out.response, out.curl, out.win
            -- out.response is nil if curl failed
        end,
    }
<


DYNAMIC VALUES                       *nurl.nvim-request-format-dynamic-values*

Use functions for dynamic values:

>lua
    return {
        {
            url = function()
                return "https://api.example.com/users/" .. vim.fn.input("User ID: ")
            end,
            headers = function()
                return {
                    ["X-Request-Id"] = tostring(os.time()),
                }
            end,
        },
    }
<


LAZY VALUES                             *nurl.nvim-request-format-lazy-values*

Use `Nurl.lazy()` for values that should only be resolved right before sending
(not during picker preview):

>lua
    return {
        url = "https://api.example.com/login",
        method = "POST",
        data = {
            username = "user",
            password = Nurl.lazy(function()
                return vim.fn.inputsecret("Password: ")
            end),
        },
    }
<


URL PARTS                                 *nurl.nvim-request-format-url-parts*

Build URLs from parts:

>lua
    return {
        {
            url = {
                env.var("base_url"),
                "v1",
                "users",
                function()
                    return vim.fn.input("ID: ")
                end,
            },
            method = "GET",
        },
    }
<


==============================================================================
9. Environments                                       *nurl.nvim-environments*

Create `.nurl/environments.lua`:

>lua
    return {
        default = {
            base_url = "https://api.example.com",
            token = "dev-token",
        },
        staging = {
            base_url = "https://staging.example.com",
            token = "staging-token",
        },
        production = {
            base_url = "https://api.example.com",
            token = "prod-token",
        },
    }
<

Access variables in requests:

>lua
    local env = require("nurl.environments")
    
    return {
        {
            url = { env.var("base_url"), "users" },
            headers = {
                ["Authorization"] = function()
                    return "Bearer " .. env.get("token")
                end,
            },
        },
    }
<

- `Nurl.env.var("name")` - Returns a function that resolves the variable (for direct use in the request object and lazy contexts)
- `Nurl.env.get("name")` - Returns the variable value immediately (for use inside functions)

>lua
    return {
        {
            url = { Nurl.env.var("base_url"), "users" },
            headers = {
                ["Authorization"] = function()
                    return "Bearer " .. Nurl.env.get("token")
                end,
            },
        },
    }
<

Switch environments with `:Nurl env`.


SETTING VARIABLES PROGRAMMATICALLY*nurl.nvim-environments-setting-variables-programmatically*

Use `env.set()` to update environment variables from hooks:

>lua
    local env = require("nurl.environments")
    
    return {
        {
            url = "https://api.example.com/login",
            method = "POST",
            data = { username = "user", password = "pass" },
            post_hook = function(out)
                local body = vim.json.decode(out.response.body)
                env.set("token", body.access_token)
            end,
        },
    }
<


ENVIRONMENT HOOKS                   *nurl.nvim-environments-environment-hooks*

Add hooks inside each environment:

>lua
    return {
        default = {
            base_url = "https://api.example.com",
        },
        production = {
            base_url = "https://api.example.com",
            pre_hook = function(next, input)
                -- Confirm before production requests
                if input.request.method ~= "GET" then
                    vim.ui.select(
                        { "Yes", "No" },
                        { prompt = "Send to production?" },
                        function(choice)
                            if choice == "Yes" then
                                next()
                            end
                        end
                    )
                else
                    next()
                end
            end,
            post_hook = function(out)
                -- Log all requests
                print(
                    out.request.method
                        .. " "
                        .. out.request.url
                        .. " -> "
                        .. out.response.status_code
                )
            end,
        },
    }
<


==============================================================================
10. API                                                        *nurl.nvim-api*

>lua
    local nurl = require("nurl")
    
    -- Send a request programmatically
    nurl.send({
        url = "https://api.example.com/users",
        method = "GET",
    }, {
        -- Optional: custom handler (skips UI)
        -- out.response is nil if curl failed
        on_complete = function(out)
            if out.response then
                print(out.response.status_code)
            end
        end,
    })
    
    -- Resend last request
    nurl.resend_last_request()
    nurl.resend_last_request(-2) -- second to last
    
    -- Get active environment
    local env_name = nurl.get_active_env()
    
    -- Winbar components (for statusline/winbar)
    nurl.winbar.status_code()
    nurl.winbar.time()
    nurl.winbar.tabs()
<


==============================================================================
11. Winbar                                                  *nurl.nvim-winbar*

The response window includes a winbar showing status code, response time, and
buffer tabs. Use these in your own winbar:

>lua
    vim.o.winbar =
        "%{%v:lua.Nurl.winbar.status_code()%}%<%{%v:lua.Nurl.winbar.request_title()%}%{%v:lua.Nurl.winbar.time()%} %=%{%v:lua.Nurl.winbar.tabs()%}"
<


==============================================================================
12. Highlight Groups                              *nurl.nvim-highlight-groups*

  Group                         Description
  ----------------------------- -------------------------
  NurlSpinner                   Loading spinner
  NurlElapsedTime               Elapsed time display
  NurlWinbarTitle               Request title in winbar
  NurlWinbarTabActive           Active tab in winbar
  NurlWinbarTabInactive         Inactive tab in winbar
  NurlWinbarSuccessStatusCode   2xx status codes
  NurlWinbarErrorStatusCode     4xx/5xx status codes
  NurlWinbarLoading             Loading state
  NurlWinbarTime                Response time
  NurlWinbarError               Error messages

==============================================================================
13. Recipes                                                *nurl.nvim-recipes*


1PASSWORD CLI FOR SECRETS        *nurl.nvim-recipes-1password-cli-for-secrets*

Use the 1Password CLI (`op`) with `nurl.lazy()` to fetch secrets only when
sending:

>lua
    local env = require("nurl.environments")
    
    local function op_get(item_id, field)
        return Nurl.lazy(function()
            local result = vim.system({
                "op",
                "item",
                "get",
                item_id,
                "--fields",
                field,
                "--format",
                "json",
            }, { text = true }):wait()
    
            if result.code ~= 0 then
                error("Failed getting op item")
            end
    
            local data = vim.json.decode(result.stdout)
            return data.value
        end)
    end
    
    return {
        {
            url = { env.var("base_url"), "auth", "login" },
            method = "POST",
            headers = {
                ["Content-Type"] = "application/json",
            },
            data = {
                username = op_get("eeljppn94azg8iqq7rrdtd1g4u", "username"),
                password = op_get("eeljppn94azg8iqq7rrdtd1g4u", "password"),
            },
            post_hook = function(out)
                local body = vim.json.decode(out.response.body)
                env.set("token", body.access_token)
            end,
        },
    }
<


OAUTH2 TOKEN REFRESH                  *nurl.nvim-recipes-oauth2-token-refresh*

Auto-refresh expired tokens before requests using environment hooks:

>lua
    -- .nurl/environments.lua
    local var = require("nurl.environments").var
    local get = require("nurl.environments").get
    local set = require("nurl.environments").set
    
    local function is_token_expired()
        local expires_at = get("expires_at")
        return not expires_at or tonumber(expires_at) < os.time()
    end
    
    local function refresh_token(next, input)
        Nurl.send({
            url = "https://auth.example.com/oauth/token",
            method = "POST",
            headers = { ["Content-Type"] = "application/json" },
            data = {
                grant_type = "refresh_token",
                refresh_token = var("refresh_token"),
            },
        }, {
            on_complete = function(out)
                if out.response and out.response.status_code == 201 then
                    local body = vim.json.decode(out.response.body)
                    set("access_token", body.access_token)
                    set("refresh_token", body.refresh_token)
                    set("expires_at", os.time() + body.expires_in)
    
                    -- This request has already been expanded before the pre_hook,
                    -- so we need to update the header here so that it reflects the
                    -- above changes.
                    input.request.headers["Authorization"] = "Bearer "
                        .. body.access_token
    
                    next()
                else
                    vim.notify("Failed to refresh token", vim.log.levels.ERROR)
                end
            end,
        })
    end
    
    return {
        default = {
            base_url = "https://api.example.com",
            access_token = nil,
            refresh_token = nil,
            expires_at = nil,
            pre_hook = function(next, input)
                if is_token_expired() then
                    refresh_token(next, input)
                else
                    next()
                end
            end,
        },
    }
<


USING RESPONSE VALUES                *nurl.nvim-recipes-using-response-values*

Store response data for use in subsequent requests:

>lua
    local nurl = require("nurl")
    local env = require("nurl.environments")
    
    return {
        {
            url = { env.var("base_url"), "users" },
            method = "POST",
            data = { name = "John Doe", email = "john@example.com" },
            post_hook = function(out)
                local user = vim.json.decode(out.response.body)
                env.set("last_user_id", user.id)
            end,
        },
        {
            url = {
                env.var("base_url"),
                "users",
                env.var("last_user_id"),
                "profile",
            },
            method = "PUT",
            data = { bio = "Software Developer" },
        },
    }
<


HMAC SIGNATURE                              *nurl.nvim-recipes-hmac-signature*

Sign requests with HMAC-SHA256:

>lua
    local env = require("nurl.environments")
    
    local function hmac_sha256(key, message)
        local result = vim.fn.system({
            "openssl",
            "dgst",
            "-sha256",
            "-hmac",
            key,
        }, message)
        return result:match("=%s*(%x+)") or ""
    end
    
    local body = '{"action":"test"}'
    
    return {
        {
            url = { env.var("base_url"), "api", "secure" },
            method = "POST",
            headers = function()
                local timestamp = tostring(os.time())
                local signature =
                    hmac_sha256(env.get("api_secret"), timestamp .. body)
                return {
                    ["Content-Type"] = "application/json",
                    ["X-Timestamp"] = timestamp,
                    ["X-Signature"] = signature,
                }
            end,
            data = body,
        },
    }
<


ENVIRONMENT-BASED CONFIRMATION*nurl.nvim-recipes-environment-based-confirmation*

Require confirmation before dangerous requests in production:

>lua
    -- .nurl/environments.lua
    return {
        development = {
            base_url = "https://dev.example.com",
        },
        production = {
            base_url = "https://api.example.com",
            pre_hook = function(next, input)
                if input.request.method == "GET" then
                    next()
                    return
                end
    
                vim.ui.select({ "Yes", "No" }, {
                    prompt = "Send to PRODUCTION?",
                }, function(choice)
                    if choice == "Yes" then
                        next()
                    end
                end)
            end,
        },
    }
<


RESPONSE VALIDATION                    *nurl.nvim-recipes-response-validation*

Validate responses and notify on failure:

>lua
    local env = require("nurl.environments")
    
    local function expect_status(codes)
        return function(request, response)
            if not vim.tbl_contains(codes, response.status_code) then
                vim.notify(
                    string.format(
                        "Unexpected status %d for %s",
                        response.status_code,
                        request.url
                    ),
                    vim.log.levels.ERROR
                )
            end
        end
    end
    
    local function expect_json_field(field)
        return function(request, response)
            local ok, body = pcall(vim.json.decode, response.body)
            if not ok or body[field] == nil then
                vim.notify("Missing field: " .. field, vim.log.levels.ERROR)
            end
        end
    end
    
    return {
        {
            url = { env.var("base_url"), "users", "123" },
            post_hook = function(out)
                expect_status({ 200, 201 })(out.request, out.response)
                expect_json_field("id")(out.request, out.response)
            end,
        },
    }
<


GRAPHQL WITH VARIABLES              *nurl.nvim-recipes-graphql-with-variables*

Build GraphQL queries programmatically:

>lua
    local env = require("nurl.environments")
    
    local function graphql(query, variables)
        return {
            url = { env.var("base_url"), "graphql" },
            method = "POST",
            headers = {
                ["Content-Type"] = "application/json",
            },
            data = {
                query = query,
                variables = variables,
            },
        }
    end
    
    return {
        graphql(
            [[
            query GetUser($id: ID!) {
                user(id: $id) {
                    id
                    name
                    email
                }
            }
        ]],
            {
                id = function()
                    return vim.fn.input("User ID: ")
                end,
            }
        ),
        graphql(
            [[
            mutation CreateUser($input: CreateUserInput!) {
                createUser(input: $input) {
                    id
                    name
                }
            }
        ]],
            {
                input = {
                    name = "John Doe",
                    email = "john@example.com",
                },
            }
        ),
    }
<


FILE UPLOAD WITH PICKER            *nurl.nvim-recipes-file-upload-with-picker*

Select a file to upload using Neovim’s UI:

>lua
    local function choose_file(next, input)
        vim.ui.input(
            { prompt = "File path: ", completion = "file" },
            function(textj)
                if text then
                    input.request.form = { file = "@" .. vim.fn.expand(text) }
                    next()
                end
            end
        )
    end
    
    return {
        {
            url = { "https://api.example.com/files/upload" },
            method = "POST",
            pre_hook = choose_file,
        },
    }
<

Generated by panvimdoc <https://github.com/kdheepak/panvimdoc>

vim:tw=78:ts=8:noet:ft=help:norl:
